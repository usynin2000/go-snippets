package main

import "fmt"


func main() {
	set := make(map[string]struct{}) // Это создаёт map (хэш-таблицу), где ключи — string, а значения — пустая структура struct{}.

	set["apple"] = struct{}{}
	set["banana"] = struct{}{}

	// Вставляем два элемента в "множество": "apple" и "banana".
	// При этом в качестве значения записываем struct{}{} — пустую структуру.

	_, ok := set["apple"]
	fmt.Println("Есть яблоко (ключ)?", ok) // true 
	
}


// Почему именно map[string]struct{}

// В Go нет встроенного типа "Set" (как в Python или Java).
// Но "множество" можно реализовать через map:

// Ключ (string) = элемент множества.

// Значение (struct{}) = просто заглушка.

// Почему не map[string]bool?

// Можно, но struct{} экономичнее:

// struct{} — пустая структура, не занимает памяти (0 байт).

// bool занимает 1 байт на каждый элемент.

// Поэтому "правильный Go-way" для множеств — map[T]struct{}.


// 3. Как пользоваться таким "множеством"

// Добавить элемент
// set["orange"] = struct{}{}


// Проверить наличие
// if _, ok := set["banana"]; ok {
//     fmt.Println("Есть банан!")
// }


// Удалить
// delete(set, "apple")

// Пройтись по множеству

// for fruit := range set {
//     fmt.Println(fruit)
// }


// 4. Итог

// map[string]struct{} — это способ реализовать Set в Go.

// Пустая структура используется, потому что она не занимает памяти → экономия.

// Такой подход — идиоматический в Go (часто встречается в open-source проектах).