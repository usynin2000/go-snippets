package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("=== Пример 1: Без горутин ===")
	// Обычный вызов функции - программа ждет завершения

	slowFunction("Функция 1")
	slowFunction("Функция 2")

	fmt.Println("Обще функции завершены\n")

	fmt.Println("=== Пример 2: С горутинами ===")
	// Запускаем функции в горутинах - они выполняются конкурентно или параллельно
	go slowFunction("Горутина 1")
	go slowFunction("Горутина 2")

	// Ждем, чтобы горутины успели выполняться
	time.Sleep(2 * time.Second)
	fmt.Println("Горутины запущены параллельно!\n")

	fmt.Println("=== Пример 3: Проблема без ожидания ===")
	// Внимание: main может завершиться раньше, чем горутины!
	go slowFunction("Горутина 3")
	fmt.Println("main завершается, но горутина может не успеть выполниться!")
}


func slowFunction(name string) {
	for i := 1; i <= 3; i++ {
		fmt.Printf("%s: шаг: %d\n", name, i)
		time.Sleep(500 * time.Millisecond)
	}
	fmt.Printf("%s: завершена\n", name)
}

// Что показывает:
// Разница между последовательным и параллельным выполнением!
// Горутины запускаются через go
// Проблема: main может завершиться раньше горутин



// Конкурентность vs параллелизм

// Горутины обеспечивают конкурентность (concurrency), но параллелизм зависит от количества ядер CPU.


// Как это работает:

// 1. На многопроцессорной системе (несколько ядер):
	// - Планировщик Go может распределить горутины по разным ядрам
	// - Они выполняются параллельно (одновременно)
// 2. На однопроцессорной системе (одно ядро):
	// - Горутины выполняются конкурентно (чередуются)
	// - Параллелизма нет


// Как работают горутины в Go

// 1. Легковесные потоки (Lightweight Threads)
// Горутины — это не системные потоки ОС, а легковесные потоки, управляемые Go runtime:
// Размер стека: ~2KB (начинается с маленького стека, растет при необходимости)
// Создание: быстро, ~1-2 микросекунды
// Переключение: быстрое, управляется планировщиком Go
// Можно запускать миллионы горутин одновременно

// 2. M:N планировщик
// Go использует модель M:N:
// M — системные потоки ОС (обычно = количество ядер CPU)
// N — горутины (может быть тысячи/миллионы)

// Планировщик Go распределяет множество горутин на небольшое количество системных потоков:

// Системные потоки ОС (M)     Горутины (N)
// ┌─────────────┐            ┌─────────┐  ┌─────────┐  ┌─────────┐
// │  Поток 1    │  ────────> │ Горутина│  │ Горутина│  │ Горутина│
// └─────────────┘            └─────────┘  └─────────┘  └─────────┘
// ┌─────────────┐            ┌─────────┐  ┌─────────┐
// │  Поток 2    │  ────────> │ Горутина│  │ Горутина│
// └─────────────┘            └─────────┘  └─────────┘


// 3. Кооперативная многозадачность
// Планировщик переключает горутины в точках:
// Вызов time.Sleep()
// Операции ввода/вывода (чтение файла, сеть)
// Операции с каналами (chan)
// Системные вызовы


// Сравнение с Python потоками

// | Аспект | Горутины Go | Потоки Python |
// |--------|-------------|--------------|
// | Управление | Go runtime | Операционная система |
// | Размер стека | ~2KB (растет) | ~1-8MB (фиксированный) |
// | Создание | ~1-2 мкс | ~100-500 мкс |
// | Переключение | ~наносекунды | ~микросекунды |
// | GIL | Нет | Есть (для CPU-bound задач) |
// | Масштабирование | Миллионы | Обычно десятки-сотни |


// Проблема GIL в Python
// В Python есть GIL (Global Interpreter Lock), который:
// Ограничивает параллельное выполнение CPU-bound задач
// Даже на многоядерном CPU одновременно выполняется только один поток Python-кода
// Для CPU-bound задач многопоточность не дает выигрыша в производительности