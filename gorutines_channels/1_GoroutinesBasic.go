package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("=== Example 1: Without Gorutines ===")
	// Ordinary func calling -> program awaits completion

	slowFunction("Func 1")
	slowFunction("Func 2")

	fmt.Println("Ordinary funcs stopped\n")

	fmt.Println("=== Example 2: With Gorutines ===")
	// Calling funcs with using of gorutines -> they will work in concurenncy 
	go slowFunction("Gorutine 1")
	go slowFunction("Gorutine 2")

	// Just to wait that gorutines completed
	time.Sleep(2 * time.Second)
	fmt.Println("Gorutines completed in parallel\n")

	fmt.Println("=== Example 3: Problem without wating ===")
	// NB! main func can be finished earlier that gorutines
	go slowFunction("Gorutine 3")
	fmt.Println("main is done, however we are not sure that gorutine is finished")
}


func slowFunction(name string) {
	for i := 1; i <= 3; i++ {
		fmt.Printf("%s: шаг: %d\n", name, i)
		time.Sleep(500 * time.Millisecond)
	}
	fmt.Printf("%s: завершена\n", name)
}

// Что показывает:
// Разница между последовательным и параллельным выполнением!
// Горутины запускаются через go
// Проблема: main может завершиться раньше горутин

// Конкурентность vs параллелизм

// Горутины обеспечивают конкурентность (concurrency), но параллелизм зависит от количества ядер CPU.


// Как это работает:

// 1. На многопроцессорной системе (несколько ядер):
	// - Планировщик Go может распределить горутины по разным ядрам
	// - Они выполняются параллельно (одновременно)
// 2. На однопроцессорной системе (одно ядро):
	// - Горутины выполняются конкурентно (чередуются)
	// - Параллелизма нет


// Как работают горутины в Go

// 1. Легковесные потоки (Lightweight Threads)
// Горутины — это не системные потоки ОС, а легковесные потоки, управляемые Go runtime:
// Размер стека: ~2KB (начинается с маленького стека, растет при необходимости)
// Создание: быстро, ~1-2 микросекунды
// Переключение: быстрое, управляется планировщиком Go
// Можно запускать миллионы горутин одновременно

// 2. M:N планировщик
// Go использует модель M:N:
// M — системные потоки ОС (обычно = количество ядер CPU)
// N — горутины (может быть тысячи/миллионы)

// Планировщик Go распределяет множество горутин на небольшое количество системных потоков:

// Системные потоки ОС (M)     Горутины (N)
// ┌─────────────┐            ┌─────────┐  ┌─────────┐  ┌─────────┐
// │  Поток 1    │  ────────> │ Горутина│  │ Горутина│  │ Горутина│
// └─────────────┘            └─────────┘  └─────────┘  └─────────┘
// ┌─────────────┐            ┌─────────┐  ┌─────────┐
// │  Поток 2    │  ────────> │ Горутина│  │ Горутина│
// └─────────────┘            └─────────┘  └─────────┘


// 3. Кооперативная многозадачность
// Планировщик переключает горутины в точках:
// Вызов time.Sleep()
// Операции ввода/вывода (чтение файла, сеть)
// Операции с каналами (chan)
// Системные вызовы


// Сравнение с Python потоками

// | Аспект | Горутины Go | Потоки Python |
// |--------|-------------|--------------|
// | Управление | Go runtime | Операционная система |
// | Размер стека | ~2KB (растет) | ~1-8MB (фиксированный) |
// | Создание | ~1-2 мкс | ~100-500 мкс |
// | Переключение | ~наносекунды | ~микросекунды |
// | GIL | Нет | Есть (для CPU-bound задач) |
// | Масштабирование | Миллионы | Обычно десятки-сотни |


// Проблема GIL в Python
// В Python есть GIL (Global Interpreter Lock), который:
// Ограничивает параллельное выполнение CPU-bound задач
// Даже на многоядерном CPU одновременно выполняется только один поток Python-кода
// Для CPU-bound задач многопоточность не дает выигрыша в производительности