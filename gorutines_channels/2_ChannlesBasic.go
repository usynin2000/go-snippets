package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("== Пример 1: Простая передача данных ===")

	// Создаем канал для передачи данных
	ch := make(chan string)

	// Горутины отправляет данные
	go func() {
		ch <- "Привет из горутины!"
		fmt.Println("Данные отправлены")
	}()

	// Ждем и читаем данные (блокируются до получения)
	message := <-ch
	fmt.Printf("Получено: %s\n\n", message)

	fmt.Println("=== Пример 2: Передача чисел ===")
	numbers := make(chan int)

	// Отправляем числа
	go func() {
		for i := 1; i <= 5; i++ {
			numbers <- i
			fmt.Printf("Отправлено : %d\n", i)
			time.Sleep(200 * time.Millisecond)
		}
		close(numbers) // // Закрываем канал после отправки всех данных
	}()

	fmt.Println("Читаем все числа:")
	
	fmt.Printf("numbers: %v\n", numbers)

	for num := range numbers {
		fmt.Printf(" Получено: %d\n", num)
	}
	fmt.Println("Все числа получены\n")

	fmt.Println("=== Пример 3: Двустороння связь ===")
	request := make(chan string)
	response := make(chan string)

	// Горутина-обработчиак
	go func () {
		for req := range request {
			response <- fmt.Sprintf("Ответ на: %s", req)
		}
	}()

	// Отправляем запросы 
	request <- "Запрос 1"
	fmt.Printf("Ответ: %s\n", <-response)

	request <- "Запрос 2"
	fmt.Printf("Ответ: %s\n", <-response)

	close(request)

}


// Создание каналов
// Отправка и чтение данных
// Использование range для чтения
// Двусторонняя связь между горутинами


// Три основных примера использвоания каналов:

// 1. Передача строкового сообщения между горутиной и основной функцией

// Создаётся канал ch := make(chan string).
// Одна горутина отправляет в канал строку.
// Основная программа читает строку из канала.

// 2. Передача нескольких чисел через канал

// Канал создаётся для int.
// Горутина отправляет в канал числа по одному, после чего канал закрывается.
// Главная функция читает числа из канала в цикле с помощью range.


// 3. Двусторонняя связь через два канала

// request и response — два разных канала.
// Горутина-«сервер» ждёт на одном канале запросы, и отправляет ответы через другой.
// Главная функция «запрашивает» и получает ответы.



// Почему нельзя просто сохранить результат работы горутины в переменную?

// Горутины исполняются параллельно, 
// и если ты просто попытаешься записывать результат работы из нескольких горутин в одну переменную 
// (например, глобальную), возникнут две основные проблемы:

// 1. Нет синхронизации доступа:

// Если несколько горутин одновременно пишут/читают из одной переменной — случаются "гонки данных" (data race). 
// Это приводит к ошибкам, которые очень сложно отследить.

// 2. Как узнать, что результат готов?

// Допустим, одна горутина обрабатывает данные, а главная функция ждёт результата. 
// Нужно как-то «иметь сигнал», когда работа завершилась — и вот для этого каналы идеально подходят. 
// Чтение из канала блокирует выполнение до тех пор, пока туда не будет что-то отправлено — и наоборот.


// Зачем вообще нужны каналы?

// Каналы — инструмент для безопасной и синхронизированной передачи данных между горутинами.

// Они решают сразу две проблемы:
// - Синхронизация: Гарантируют, что данные будут прочитаны только после того, как они реально появились.
// - Безопасность: Исключают гонки данных без сложных ручных блокировок.


// Классическая альтернатива каналам — использовать примитивы синхронизации (mutex, waitgroup и т.д.) и делить переменные. 
// Но это более сложно, легко ошибиться. Каналы же реализуют концепцию "общения" между потоками, а не "общей памяти".
// В Go рекомендуемый стиль:
// > "Не общайтесь через общую память, а разделяйте память через общение"
// > (Do not communicate by sharing memory; instead, share memory by communicating)