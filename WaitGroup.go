// Все три воркера работают параллельно (или псевдопараллельно, если у тебя одно ядро).
// Порядок вывода может быть разным при каждом запуске.

package main

import (
	"fmt"
	"sync"
)

func worker(id int, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Printf("Worker %d is working\n", id)
}

// id — номер рабочего (просто для примера).

// wg — указатель на WaitGroup, общий для всех горутин.

// defer wg.Done() — гарантирует, что при выходе из функции будет вызван wg.Done(), уменьшающий счётчик активных задач на 1.

// fmt.Printf(...) — просто печатает сообщение.

func main() {
	var wg sync.WaitGroup // var wg sync.WaitGroup — создаётся группа ожидания.
	for i := 1; i <= 3; i++ {
		wg.Add(1) // увеличивает счётчик задач на 1 (говорим: «будет ещё одна горутина»).
		go worker(i, &wg) // запускает функцию worker как горутинию, то есть в отдельном потоке выполнения
	}
	
	wg.Wait()
	// После запуска всех горутин вызывается wg.Wait() — блокирует выполнение main, пока все горутины не вызовут wg.Done().

	fmt.Println("all workers are done\n")

	// Когда счётчик дойдёт до 0, программа продолжает выполнение и печатает "all workers are done".
}

// Она запускает три параллельных горутины
// и затем ждёт, пока все они закончат работу, прежде чем вывести
// all workers are done.